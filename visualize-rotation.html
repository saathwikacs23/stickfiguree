<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLB 3D Rotation Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            z-index: 100;
            min-width: 280px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        #x-slider {
            background: linear-gradient(to right, #ff4444, #ffaaaa);
        }
        #y-slider {
            background: linear-gradient(to right, #44ff44, #aaffaa);
        }
        #z-slider {
            background: linear-gradient(to right, #4444ff, #aaaaff);
        }
        .value-display {
            min-width: 50px;
            text-align: right;
            font-weight: bold;
            color: #555;
        }
        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        button:hover {
            background: #45a049;
        }
        h2 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
        }
        #axes-helper {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        .axis-label {
            margin: 5px 0;
        }
        .x-axis { color: #ff0000; font-weight: bold; }
        .y-axis { color: #00ff00; font-weight: bold; }
        .z-axis { color: #0000ff; font-weight: bold; }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    
    <div id="controls">
        <h2>üéÆ Rotation Controls</h2>
        
        <div class="control-group">
            <label>X-Axis Rotation (Red)</label>
            <div class="slider-container">
                <input type="range" id="x-slider" min="-180" max="180" value="0" step="1">
                <span class="value-display" id="x-value">0¬∞</span>
            </div>
        </div>
        
        <div class="control-group">
            <label>Y-Axis Rotation (Green)</label>
            <div class="slider-container">
                <input type="range" id="y-slider" min="-180" max="180" value="0" step="1">
                <span class="value-display" id="y-value">0¬∞</span>
            </div>
        </div>
        
        <div class="control-group">
            <label>Z-Axis Rotation (Blue)</label>
            <div class="slider-container">
                <input type="range" id="z-slider" min="-180" max="180" value="0" step="1">
                <span class="value-display" id="z-value">0¬∞</span>
            </div>
        </div>
        
        <button id="reset-btn">Reset Rotation</button>
        
        <h2 style="margin-top: 20px;">üîÑ Top Cylinder</h2>
        
        <div class="control-group">
            <label>X-Axis Rotation (Red)</label>
            <div class="slider-container">
                <input type="range" id="x-slider2" min="-180" max="180" value="0" step="1">
                <span class="value-display" id="x-value2">0¬∞</span>
            </div>
        </div>
        
        <div class="control-group">
            <label>Y-Axis Rotation (Green)</label>
            <div class="slider-container">
                <input type="range" id="y-slider2" min="-180" max="180" value="0" step="1">
                <span class="value-display" id="y-value2">0¬∞</span>
            </div>
        </div>
        
        <div class="control-group">
            <label>Z-Axis Rotation (Blue)</label>
            <div class="slider-container">
                <input type="range" id="z-slider2" min="-180" max="180" value="0" step="1">
                <span class="value-display" id="z-value2">0¬∞</span>
            </div>
        </div>
        
        <button id="reset-btn2">Reset Top Cylinder</button>
        
        <h2 style="margin-top: 20px;">üåê ESP32 Connection</h2>
        
        <div class="control-group">
            <label>ESP32 IP Address</label>
            <input type="text" id="esp-ip" placeholder="192.168.1.100" style="width: 100%; padding: 5px;">
        </div>
        
        <div class="control-group">
            <button id="connect-btn">Connect & Start</button>
            <button id="stop-btn" disabled>Stop</button>
            <button id="ack-btn" disabled>Send ACK</button>
            <span id="status" style="margin-left: 10px;">Disconnected</span>
        </div>
    </div>
    
    <div id="axes-helper">
        <div class="axis-label x-axis">X-Axis: Red ‚Üí</div>
        <div class="axis-label y-axis">Y-Axis: Green ‚Üë</div>
        <div class="axis-label z-axis">Z-Axis: Blue ‚äô</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene setup
        const canvas = document.getElementById('canvas');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2a2a2a);

        // Camera
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(3, 3, 3);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvas,
            antialias: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight1.position.set(5, 5, 5);
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
        directionalLight2.position.set(-5, -5, -5);
        scene.add(directionalLight2);

        // Add grid helper
        const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        scene.add(gridHelper);

        // Add axes helper
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);

        // Add origin marker (sphere at 0,0,0)
        const originGeometry = new THREE.SphereGeometry(0.1, 16, 16);
        const originMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const originMarker = new THREE.Mesh(originGeometry, originMaterial);
        originMarker.position.set(0, 0, 0);
        scene.add(originMarker);

        // Add origin circle on grid plane
        const circleGeometry = new THREE.RingGeometry(0.15, 0.2, 32);
        const circleMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffff00, 
            side: THREE.DoubleSide 
        });
        const originCircle = new THREE.Mesh(circleGeometry, circleMaterial);
        originCircle.rotation.x = -Math.PI / 2;
        originCircle.position.y = 0.01;
        scene.add(originCircle);

        // Orbit controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Load GLB model
        let model;
        let model2; // Second model on top
        let pivotGroup; // Parent group for pivot control
        let pivotGroup2; // Parent group for second model
        let joinMarker; // Marker at the joining point
        let secondOriginMarker; // Marker at the origin of second cylinder
        const loader = new GLTFLoader();
        
        loader.load(
            'entity (3).glb',
            function (gltf) {
                model = gltf.scene;
                
                // Calculate bounding box
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const min = box.min;
                const max = box.max;
                const height = max.y - min.y;
                
                // Create pivot group at origin
                pivotGroup = new THREE.Group();
                pivotGroup.position.set(0, 0, 0);
                
                // Offset model relative to pivot (bottom surface at origin)
                model.position.set(-center.x, -min.y, -center.z);
                
                pivotGroup.add(model);
                scene.add(pivotGroup);
                console.log('First model loaded - pivot at origin, bottom surface aligned');
                
                // Load second model on top
                loader.load(
                    'entity (3).glb',
                    function (gltf2) {
                        model2 = gltf2.scene;
                        
                        // Calculate bounding box for second model
                        const box2 = new THREE.Box3().setFromObject(model2);
                        const center2 = box2.getCenter(new THREE.Vector3());
                        const min2 = box2.min;
                        
                        // Create pivot group for second model at the center of joining surface
                        // Position at the center axis of the top of first cylinder
                        pivotGroup2 = new THREE.Group();
                        pivotGroup2.position.set(0, height, 0); // At center of top surface (x=0, z=0 on axis)
                        
                        // Offset second model so center of its bottom surface is at pivot
                        model2.position.set(-center2.x, -min2.y, -center2.z);
                        pivotGroup2.add(model2);
                        scene.add(pivotGroup2);
                        
                        // Add visual marker at the joining pivot point (child of first cylinder's pivot group)
                        const joinMarkerGeometry = new THREE.SphereGeometry(0.08, 16, 16);
                        const joinMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
                        joinMarker = new THREE.Mesh(joinMarkerGeometry, joinMarkerMaterial);
                        joinMarker.position.set(0, height, 0);
                        pivotGroup.add(joinMarker); // Add to first cylinder's pivot group so it rotates with it
                        
                        // Add marker at the origin of second cylinder (center of its bottom surface)
                        const secondOriginGeometry = new THREE.SphereGeometry(0.08, 16, 16);
                        const secondOriginMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff }); // Cyan color
                        secondOriginMarker = new THREE.Mesh(secondOriginGeometry, secondOriginMaterial);
                        secondOriginMarker.position.set(0, 0, 0); // At pivot point of second cylinder
                        pivotGroup2.add(secondOriginMarker); // Child of second cylinder so it rotates with it
                        
                        console.log('Second model loaded - pivot at center axis of top surface');
                        console.log('Second model loaded - pivot at center axis of top surface');
                    },
                    function (xhr) {
                        console.log('Second model: ' + (xhr.loaded / xhr.total * 100) + '% loaded');
                    },
                    function (error) {
                        console.error('Error loading second model:', error);
                    }
                );
            },
            function (xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function (error) {
                console.error('Error loading model:', error);
            }
        );

        // WebSocket for ESP32
        let ws = null;
        let ackTimeout = null;
        const espIpInput = document.getElementById('esp-ip');
        const connectBtn = document.getElementById('connect-btn');
        const stopBtn = document.getElementById('stop-btn');
        const ackBtn = document.getElementById('ack-btn');
        const statusSpan = document.getElementById('status');

        function connectWebSocket() {
            const ip = espIpInput.value.trim();
            if (!ip) {
                alert('Please enter ESP32 IP address');
                return;
            }
            const url = `ws://${ip}/ws`;
            ws = new WebSocket(url);
            ws.binaryType = "arraybuffer";

            ws.onopen = function() {
                statusSpan.textContent = 'Connected';
                statusSpan.style.color = 'green';
                connectBtn.disabled = true;
                stopBtn.disabled = false;
                ackBtn.disabled = false;
                ws.send('sendAngles');
            };

            ws.onclose = function() {
                if (ackTimeout) clearTimeout(ackTimeout);
                statusSpan.textContent = 'Disconnected';
                statusSpan.style.color = 'red';
                connectBtn.disabled = false;
                stopBtn.disabled = true;
                ackBtn.disabled = true;
                ws = null;
            };

            ws.onerror = function(error) {
                console.error('WebSocket error:', error);
                statusSpan.textContent = 'Error';
                statusSpan.style.color = 'red';
            };

            ws.onmessage = function(event) {
                console.log("goit avbles")
                if (event.data instanceof ArrayBuffer) {
                    console.log("inside bytes")
                    // Clear previous timeout
                    if (ackTimeout) clearTimeout(ackTimeout);

                    const dataView = new DataView(event.data);
                    const roll1 = dataView.getFloat32(0, true);
                    const pitch1 = dataView.getFloat32(4, true);
                    const yaw1 = dataView.getFloat32(8, true);
                    const roll2 = dataView.getFloat32(12, true);
                    const pitch2 = dataView.getFloat32(16, true);
                    const yaw2 = dataView.getFloat32(20, true);

                    // Update first model
                    if (pivotGroup) {
                        pivotGroup.rotation.set(
                            THREE.MathUtils.degToRad(roll1),
                            THREE.MathUtils.degToRad(pitch1),
                            THREE.MathUtils.degToRad(yaw1)
                        );
                        // Update position of second model
                        if (pivotGroup2 && joinMarker) {
                            const worldPos = new THREE.Vector3();
                            joinMarker.getWorldPosition(worldPos);
                            pivotGroup2.position.copy(worldPos);
                        }
                    }

                    // Update second model
                    if (pivotGroup2) {
                        pivotGroup2.rotation.set(
                            THREE.MathUtils.degToRad(roll2),
                            THREE.MathUtils.degToRad(pitch2),
                            THREE.MathUtils.degToRad(yaw2)
                        );
                    }

                    // Update slider values for display
                    xSlider.value = roll1;
                    ySlider.value = pitch1;
                    zSlider.value = yaw1;
                    xValue.textContent = roll1.toFixed(1) + '¬∞';
                    yValue.textContent = pitch1.toFixed(1) + '¬∞';
                    zValue.textContent = yaw1.toFixed(1) + '¬∞';

                    xSlider2.value = roll2;
                    ySlider2.value = pitch2;
                    zSlider2.value = yaw2;
                    xValue2.textContent = roll2.toFixed(1) + '¬∞';
                    yValue2.textContent = pitch2.toFixed(1) + '¬∞';
                    zValue2.textContent = yaw2.toFixed(1) + '¬∞';

                    // Send ack to continue receiving
                    if (ws) ws.send('ack');

                    // Set timeout to send ack again in 200ms
                    ackTimeout = setTimeout(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send('ack');
                        }
                    }, 200);
                }
            };
        }

        function stopWebSocket() {
            if (ackTimeout) clearTimeout(ackTimeout);
            if (ws) {
                ws.send('stopAngles');
                ws.close();
            }
        }

        // Control elements
        const xSlider = document.getElementById('x-slider');
        const ySlider = document.getElementById('y-slider');
        const zSlider = document.getElementById('z-slider');
        const xValue = document.getElementById('x-value');
        const yValue = document.getElementById('y-value');
        const zValue = document.getElementById('z-value');
        const resetBtn = document.getElementById('reset-btn');
        
        // Control elements for second model
        const xSlider2 = document.getElementById('x-slider2');
        const ySlider2 = document.getElementById('y-slider2');
        const zSlider2 = document.getElementById('z-slider2');
        const xValue2 = document.getElementById('x-value2');
        const yValue2 = document.getElementById('y-value2');
        const zValue2 = document.getElementById('z-value2');
        const resetBtn2 = document.getElementById('reset-btn2');

        // Update rotation for first model
        function updateRotation() {
            if (pivotGroup) {
                const xRad = THREE.MathUtils.degToRad(parseFloat(xSlider.value));
                const yRad = THREE.MathUtils.degToRad(parseFloat(ySlider.value));
                const zRad = THREE.MathUtils.degToRad(parseFloat(zSlider.value));
                
                pivotGroup.rotation.set(xRad, yRad, zRad);
                
                // Update second cylinder's position to follow the rotated top point
                if (pivotGroup2 && joinMarker) {
                    const worldPos = new THREE.Vector3();
                    joinMarker.getWorldPosition(worldPos);
                    pivotGroup2.position.copy(worldPos);
                }
            }
        }
        
        // Update rotation for second model
        function updateRotation2() {
            if (pivotGroup2) {
                const xRad = THREE.MathUtils.degToRad(parseFloat(xSlider2.value));
                const yRad = THREE.MathUtils.degToRad(parseFloat(ySlider2.value));
                const zRad = THREE.MathUtils.degToRad(parseFloat(zSlider2.value));
                
                pivotGroup2.rotation.set(xRad, yRad, zRad);
            }
        }

        // Slider event listeners
        xSlider.addEventListener('input', function() {
            xValue.textContent = this.value + '¬∞';
            updateRotation();
        });

        ySlider.addEventListener('input', function() {
            yValue.textContent = this.value + '¬∞';
            updateRotation();
        });

        zSlider.addEventListener('input', function() {
            zValue.textContent = this.value + '¬∞';
            updateRotation();
        });
        
        // Slider event listeners for second model
        xSlider2.addEventListener('input', function() {
            xValue2.textContent = this.value + '¬∞';
            updateRotation2();
        });

        ySlider2.addEventListener('input', function() {
            yValue2.textContent = this.value + '¬∞';
            updateRotation2();
        });

        zSlider2.addEventListener('input', function() {
            zValue2.textContent = this.value + '¬∞';
            updateRotation2();
        });

        // Reset button
        resetBtn.addEventListener('click', function() {
            xSlider.value = 0;
            ySlider.value = 0;
            zSlider.value = 0;
            xValue.textContent = '0¬∞';
            yValue.textContent = '0¬∞';
            zValue.textContent = '0¬∞';
            updateRotation();
        });
        
        // Reset button for second model
        resetBtn2.addEventListener('click', function() {
            xSlider2.value = 0;
            ySlider2.value = 0;
            zSlider2.value = 0;
            xValue2.textContent = '0¬∞';
            yValue2.textContent = '0¬∞';
            zValue2.textContent = '0¬∞';
            updateRotation2();
        });
        ySlider.addEventListener('input', function() {
            yValue.textContent = this.value + '¬∞';
            updateRotation();
        });

        zSlider.addEventListener('input', function() {
            zValue.textContent = this.value + '¬∞';
            updateRotation();
        });

        // Reset button
        resetBtn.addEventListener('click', function() {
            xSlider.value = 0;
            ySlider.value = 0;
            zSlider.value = 0;
            xValue.textContent = '0¬∞';
            yValue.textContent = '0¬∞';
            zValue.textContent = '0¬∞';
            updateRotation();
        });
        
        // Reset button for second model
        resetBtn2.addEventListener('click', function() {
            xSlider2.value = 0;
            ySlider2.value = 0;
            zSlider2.value = 0;
            xValue2.textContent = '0¬∞';
            yValue2.textContent = '0¬∞';
            zValue2.textContent = '0¬∞';
            updateRotation2();
        });

        // WebSocket event listeners
        connectBtn.addEventListener('click', connectWebSocket);
        stopBtn.addEventListener('click', stopWebSocket);
        ackBtn.addEventListener('click', function() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send('ack');
            }
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // Keep second cylinder's pivot following the magenta marker
            if (pivotGroup2 && joinMarker) {
                const worldPos = new THREE.Vector3();
                joinMarker.getWorldPosition(worldPos);
                pivotGroup2.position.copy(worldPos);
            }
            
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
